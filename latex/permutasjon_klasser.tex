\documentclass{article}
\usepackage{amsmath}
%\usepackage[linesnumbered,lined,boxed,commentsnumbered]{algorithm2e}
\usepackage[]{algorithm}
\usepackage[noend]{algpseudocode}

% stuff
%\usepackage[]{amsmath}
%\algblock{Input}{EndInput}
%\algonext{EndInput}
%\newcommand{\Desc}[2]{\State \makebox[2em][1]{#1}#2}
%\algblock{Output}{EndOutput}

\begin{document}

%An object property p is a binary relation of the form r(x, y). It is possible to restrict what values the x can be, called the domain of the property. The same with y, called the range of the property.

%The ontology contains all the data such as individuals, object properties, etc.




\begin{algorithm}
\caption{OWL API Object Class Permuter}
\begin{algorithmic}[0]
%\State This algorithm permutes with properties where the given individual can be in the domain. Permutation for properties where the individual can be in the domain works similarly.
%\State

%\State There is implicit access to an ontology object $ont$ where all classes, properties, individuals, etc. can be found.
\State The ontology object $ontology$ has access to all classes, properties, individuals, etc. in the ontology.
\State The list $unknowns$ is a list of individuals to be permuted.
\State
\State Assumptions:
\State 1. An individual which is set to unknown is of a class type where each of the sub-classes can only have one value in the ABox.
\State 2. All information about an individual in class-form are classes that are sub-classes of a main class.
\State 3. Need some kind of assumption that makes it possible to do this: $superClass \leftarrow$ The super-class of u on the depth below owl:Thing/Top
\State Gir disse antagelsene i det hele tatt mening?
\State
%\State Reasoner $r$ can check consistency of the ontology $ont$

\Procedure {permute}{$Ontology:ontology, List:permutables$}
%	\State flush reasoner

	\If {$ontology$ is inconsistent}
		\State return
		\State
	\EndIf	

	
	\If {$permutables$ is empty}
		\State write (consistent) $ontology$ to file
		\State return
		\State
	\EndIf
	
	\State $List:restOfPermutables \leftarrow$ copy of $permutables$ without the first element
	\State $Individual:u \leftarrow$ first element of $permutables$
	\State
	%\State $superClass \leftarrow$ the super class of u on the depth below owl:Thing/Top
	\State // smallest as in lowest in the class hierarchy
	\State $Class:superClass \leftarrow$ the "smallest" super class of all the class assertions of $u$
	\State $List:directSubclasses \leftarrow$ all direct sub classes of $superClass$
	\State $List:axiomLists \leftarrow$ instantiate new list (which is a list of lists)
	\State
	
	\ForAll {$c_s \in directSubclasses$}
		\State $List:leafSubclasses \leftarrow$ all sub classes of $c_s$ without sub classes
		\State  add generateAxioms($leafSubclasses, u$) to $axiomLists$
		%\State add a list of 
	\EndFor

	\State	
	\State $List:permutations \leftarrow$ all permutations of the lists in $axiomLists$
	\State
	\ForAll {$permutation \in permutations$}
		\State $List:newAxioms \leftarrow$ new list
		\State
		\State // make sure to not add and remove an axiom that is already in the $ontology$
		\ForAll {$a \in permutation$}
			\If {$a \notin ontology$}
				\State add $a$ to $newAxioms$
						
			\EndIf
		\EndFor
		\State
		\ForAll {$a \in newAxioms$}
			\State add $a$ to the $ontology$
		\EndFor
		\State
		\State permute($ontology, restOfPermutables$)
		\State
		\ForAll {$a \in newAxioms$}
			\State remove $a$ from the $ontology$
		\EndFor
	\EndFor
	
\EndProcedure
\end{algorithmic}
\end{algorithm}

%The legalClasses are currently defined as all inferered leaf sub-classes of the individual's "main" class.

%\newpage


\begin{algorithm}
\caption{Helper Method(s)}
\begin{algorithmic}
\State Generates a list of axiom lists, i.e. [[Reservoir($u$), Shale($u$)], [InFeederchannel($u$), InDistributarychannel($u$)]]
\Procedure {generateAxioms}{$List:leafClasses, Individual:u$}
\State $List:axioms \leftarrow$ new list
\State
\ForAll {$c_l \in leafClasses$}
	\State $Axiom:a \leftarrow$ assert $u$ is of class $c_l$
	\State add $a$ to $axioms$
\EndFor
\State
\State return $axioms$
\EndProcedure


%\State
%\State
%\Procedure {generatePermutations}{$List:axiomLists, List:currentPermutation, List:allPermutations$}
%\If {$axiomLists$ is empty}
%	\State add $currentPermutation$ to $allPermutations$
%\EndIf
%\State
%\State $List:axioms \leftarrow$ first element of $axiomLists$
%\State
%\ForAll {$a \in axioms$}	
%\EndFor
%\EndProcedure

\end{algorithmic}
\end{algorithm}

\end{document} 